var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
import { openBlock, createBlock, resolveDynamicComponent, normalizeClass, normalizeStyle, withCtx, createElementBlock, Fragment, mergeProps, createCommentVNode, createTextVNode, toDisplayString, withDirectives, renderSlot, createElementVNode, vShow, resolveComponent, createSlots, createVNode, withKeys, renderList } from "vue";
const _hoisted_1$1 = ["src"];
const _hoisted_2$1 = ["src"];
const _hoisted_3$1 = ["src"];
const _hoisted_4$1 = ["src"];
const _hoisted_5$1 = ["src"];
const _hoisted_6$1 = { key: 2 };
const _hoisted_7$1 = { class: "vueperslide__content-wrapper" };
const _hoisted_8$1 = ["innerHTML"];
const _hoisted_9$1 = ["innerHTML"];
const _hoisted_10$1 = { class: "vueperslide__content-wrapper" };
const _hoisted_11$1 = ["innerHTML"];
const _hoisted_12$1 = ["innerHTML"];
const _hoisted_13$1 = {
  key: 4,
  class: "vueperslide__loader"
};
function render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent($props.link ? "a" : "div"), {
    class: normalizeClass(["vueperslide", $options.slideClasses]),
    href: $props.link && !$options.justDragged ? $props.link : false,
    target: $props.link && $props.openInNew ? typeof $props.openInNew === "boolean" ? "_blank" : $props.openInNew : "_self",
    face: $options.slideFace3d,
    style: normalizeStyle($options.slideStyles),
    "aria-hidden": $options.slides.activeId === _ctx._.uid || $options.isSlideVisible ? "false" : "true",
    onMouseenter: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("mouse-enter", { slideIndex: $options.slideIndex, title: $props.title, content: $props.content, image: $props.image, link: $props.link }, _ctx.$el)),
    onMouseleave: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("mouse-leave"))
  }, {
    default: withCtx(() => [
      $options.videoObj ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        $options.videoObj.webm || $options.videoObj.mp4 ? (openBlock(), createElementBlock("video", mergeProps({
          key: 0,
          class: "vueperslide__video",
          width: "100%",
          height: "100%"
        }, $options.videoObj.props || {}), [
          $options.videoObj.webm ? (openBlock(), createElementBlock("source", {
            key: 0,
            src: $options.videoObj.webm,
            type: "video/webm"
          }, null, 8, _hoisted_1$1)) : createCommentVNode("", true),
          $options.videoObj.mp4 ? (openBlock(), createElementBlock("source", {
            key: 1,
            src: $options.videoObj.mp4,
            type: "video/mp4"
          }, null, 8, _hoisted_2$1)) : createCommentVNode("", true),
          $options.videoObj.ogv ? (openBlock(), createElementBlock("source", {
            key: 2,
            src: $options.videoObj.ogv,
            type: "video/ogg"
          }, null, 8, _hoisted_3$1)) : createCommentVNode("", true),
          $options.videoObj.avi ? (openBlock(), createElementBlock("source", {
            key: 3,
            src: $options.videoObj.avi,
            type: "video/avi"
          }, null, 8, _hoisted_4$1)) : createCommentVNode("", true),
          createTextVNode(toDisplayString($options.videoObj.alt || "Sorry, your browser doesn't support embedded videos."), 1)
        ], 16)) : $options.videoObj.url ? (openBlock(), createElementBlock("iframe", mergeProps({
          key: 1,
          class: "vueperslide__video",
          src: $options.videoObj.url,
          type: "text/html",
          frameborder: "0",
          width: "100%",
          height: "100%"
        }, $options.videoObj.props || {}), null, 16, _hoisted_5$1)) : createCommentVNode("", true)
      ], 64)) : createCommentVNode("", true),
      _ctx.imageSrc && $options.conf.slideImageInside ? (openBlock(), createElementBlock("div", {
        key: 1,
        class: "vueperslide__image",
        style: normalizeStyle($options.imageStyles)
      }, null, 4)) : createCommentVNode("", true),
      $options.conf.slideContentOutside ? withDirectives((openBlock(), createElementBlock("div", _hoisted_6$1, [
        renderSlot(_ctx.$slots, "content", {}, () => [
          createElementVNode("div", _hoisted_7$1, [
            $props.title ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: "vueperslide__title",
              innerHTML: $props.title
            }, null, 8, _hoisted_8$1)) : createCommentVNode("", true),
            $props.content ? (openBlock(), createElementBlock("div", {
              key: 1,
              class: "vueperslide__content",
              innerHTML: $props.content
            }, null, 8, _hoisted_9$1)) : createCommentVNode("", true)
          ])
        ])
      ], 512)), [
        [vShow, false]
      ]) : renderSlot(_ctx.$slots, "content", { key: 3 }, () => [
        createElementVNode("div", _hoisted_10$1, [
          $props.title ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "vueperslide__title",
            innerHTML: $props.title
          }, null, 8, _hoisted_11$1)) : createCommentVNode("", true),
          $props.content ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: "vueperslide__content",
            innerHTML: $props.content
          }, null, 8, _hoisted_12$1)) : createCommentVNode("", true)
        ])
      ]),
      $options.conf.lazy && !_ctx.loaded ? (openBlock(), createElementBlock("div", _hoisted_13$1, [
        renderSlot(_ctx.$slots, "loader")
      ])) : createCommentVNode("", true)
    ]),
    _: 3
  }, 40, ["href", "target", "class", "face", "style", "aria-hidden"]);
}
var vueperslide_vue_vue_type_style_index_0_lang = "";
var _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const _sfc_main$1 = {
  inject: ["slides", "touch", "updateSlide", "addClone", "addSlide", "removeSlide"],
  props: {
    clone: { type: Boolean },
    image: { type: String, default: "" },
    video: { type: [String, Object], default: "" },
    title: { type: String, default: "" },
    content: { type: String, default: "" },
    link: { type: String, default: "" },
    duration: { type: Number, default: 0 },
    lazyloaded: { type: Boolean },
    openInNew: { type: [Boolean, String] }
  },
  emits: ["mouse-enter", "mouse-leave"],
  data: () => ({
    imageSrc: "",
    loading: false,
    loaded: false
  }),
  computed: {
    conf() {
      return this.$parent.conf;
    },
    slideClasses() {
      return {
        "vueperslide--active": this.slides.activeId === this._.uid,
        "vueperslide--previous-slide": this.isPreviousSlide,
        "vueperslide--next-slide": this.isNextSlide,
        "vueperslide--visible": this.isSlideVisible,
        "vueperslide--loading": this.conf.lazy && !this.loaded,
        "vueperslide--has-video": this.videoObj,
        "vueperslide--has-image-inside": this.conf.slideImageInside,
        "vueperslide--no-pointer-events": this.videoObj && this.videoObj.pointerEvents === false
      };
    },
    slideStyles() {
      const { visibleSlides, fade, slideImageInside, gap, gapPx } = this.conf;
      return __spreadValues(__spreadValues(__spreadValues(__spreadValues({}, !slideImageInside && this.imageSrc && { backgroundImage: `url("${this.imageSrc}")` }), visibleSlides > 1 && { width: (100 - (gap ? gap * (visibleSlides - 1) : 0)) / visibleSlides + "%" }), visibleSlides > 1 && fade && { [this.conf.rtl ? "right" : "left"]: this.slideIndex % visibleSlides / visibleSlides * 100 + "%" }), gap && { [this.conf.rtl ? "marginLeft" : "marginRight"]: gap + (gapPx ? "px" : "%") });
    },
    videoObj() {
      if (!this.video)
        return null;
      let video = { url: "", alt: "", props: { controls: true } };
      if (typeof this.video === "object")
        video = Object.assign(video, this.video);
      else if (typeof this.video === "string")
        video.url = this.video;
      return video;
    },
    youtubeVideo() {
      return /youtube\.|youtu\.be/.test(this.videoObj.url);
    },
    imageStyles() {
      return __spreadValues({}, this.conf.slideImageInside && this.imageSrc && { backgroundImage: `url("${this.imageSrc}")` });
    },
    slideFace3d() {
      if (!this.conf["3d"])
        return false;
      const faces = ["front", "right", "back", "left"];
      const prevSlideIndex = (this.slides.current - 1 + this.slidesCount) % this.slidesCount;
      const nextSlideIndex = (this.slides.current + 1) % this.slidesCount;
      let face = "front";
      if (this.slideIndex === prevSlideIndex)
        face = faces[(4 + this.slides.current - 1) % 4];
      else if (this.slideIndex === nextSlideIndex)
        face = faces[(this.slides.current + 1) % 4];
      face = faces[this.slideIndex % 4];
      if (this.conf.rtl && face === "left")
        face = "right";
      else if (this.conf.rtl && face === "right")
        face = "left";
      return face;
    },
    isPreviousSlide() {
      if (!this.conf["3d"])
        return false;
      const prevSlideIndex = (this.slides.current - 1 + this.slidesCount) % this.slidesCount;
      return this._.uid === this.slides.list[prevSlideIndex].id;
    },
    isNextSlide() {
      if (!this.conf["3d"])
        return false;
      const nextSlideIndex = (this.slides.current + 1) % this.slidesCount;
      return this._.uid === this.slides.list[nextSlideIndex].id;
    },
    isSlideVisible() {
      return this.slideIndex >= this.slides.firstVisible && this.slideIndex < this.slides.firstVisible + this.conf.visibleSlides;
    },
    slidesList() {
      return this.slides.list.map((slide) => slide.id);
    },
    slidesCount() {
      return this.slidesList.length;
    },
    slideIndex() {
      return this.slidesList.indexOf(this._.uid);
    },
    justDragged() {
      return this.touch.justDragged;
    }
  },
  methods: {
    updateThisSlide(props) {
      this.updateSlide(this._.uid, props);
    },
    loadImage() {
      if (this.loading || this.loaded)
        return;
      this.loading = true;
      return new Promise((resolve, reject) => {
        const img = document.createElement("img");
        img.onload = () => {
          this.imageSrc = this.image;
          this.loading = false;
          this.loaded = true;
          this.$nextTick(() => {
            resolve({ image: this.imageSrc, style: ((this.$el.attributes || {}).style || {}).value });
          });
        };
        img.onerror = (this.loading = false) || reject;
        img.src = this.image;
      });
    },
    playVideo() {
      if (!this.videoObj)
        return;
      if (this.videoObj.url) {
        this.$el.querySelector("iframe").contentWindow.postMessage('{"event":"command","func":"playVideo","args":""}', "*");
      } else
        this.$el.querySelector("video").play();
    },
    pauseVideo() {
      if (!this.videoObj)
        return;
      if (this.videoObj.url) {
        this.$el.querySelector("iframe").contentWindow.postMessage('{"event":"command","func":"pauseVideo","args":""}', "*");
      } else
        this.$el.querySelector("video").pause();
    }
  },
  created() {
    this.imageSrc = this.conf.lazy ? "" : this.image;
    if (this.clone)
      return this.addClone();
    this.addSlide({
      id: this._.uid,
      image: this.imageSrc,
      video: this.videoObj && __spreadProps(__spreadValues({}, this.videoObj), { play: this.playVideo, pause: this.pauseVideo }),
      title: this.title,
      content: this.content,
      contentSlot: this.$slots.content,
      loaderSlot: this.$slots.loader,
      link: this.link,
      style: "",
      loadImage: this.loadImage,
      duration: this.duration
    });
  },
  mounted() {
    if (this.clone)
      return;
    this.updateThisSlide({
      contentSlot: this.$slots.content,
      loaderSlot: this.$slots.loader,
      style: ((this.$el.attributes || {}).style || {}).value
    });
  },
  beforeUnmount() {
    if (!this.clone)
      this.removeSlide(this._.uid);
  },
  watch: {
    image() {
      this.imageSrc = this.conf.lazy && !this.isSlideVisible ? "" : this.image;
      if (!this.clone) {
        this.updateThisSlide(__spreadValues({
          image: this.imageSrc
        }, !this.conf.slideImageInside && { style: this.slideStyles }));
      }
    },
    title() {
      if (!this.clone)
        this.updateThisSlide({ title: this.title });
    },
    content() {
      if (!this.clone)
        this.updateThisSlide({ content: this.content });
    },
    link() {
      if (!this.clone)
        this.updateThisSlide({ link: this.link });
    },
    lazyloaded() {
      if (this.clone)
        this.loaded = this.lazyloaded;
    }
  }
};
var VueperSlide = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", render$1]]);
var styles = "";
const _hoisted_1 = ["innerHTML"];
const _hoisted_2 = ["innerHTML"];
const _hoisted_3 = { class: "vueperslides__inner" };
const _hoisted_4 = {
  key: 0,
  class: "vueperslides__paused"
};
const _hoisted_5 = {
  key: 1,
  class: "vueperslides__progress"
};
const _hoisted_6 = {
  key: 2,
  class: "vueperslides__fractions"
};
const _hoisted_7 = { viewBox: "0 0 9 18" };
const _hoisted_8 = ["d"];
const _hoisted_9 = { viewBox: "0 0 9 18" };
const _hoisted_10 = ["d"];
const _hoisted_11 = {
  key: 4,
  class: "vueperslides__bullets",
  ref: "bullets",
  role: "tablist",
  "aria-label": "Slideshow navigation"
};
const _hoisted_12 = ["aria-label", "onClick"];
const _hoisted_13 = { class: "default" };
const _hoisted_14 = {
  key: 1,
  class: "vueperslides__bullets vueperslides__bullets--outside",
  ref: "bullets",
  role: "tablist",
  "aria-label": "Slideshow navigation"
};
const _hoisted_15 = ["aria-label", "onClick"];
const _hoisted_16 = { class: "default" };
const _hoisted_17 = ["innerHTML"];
const _hoisted_18 = ["innerHTML"];
function render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_vnodes = resolveComponent("vnodes");
  const _component_vueper_slide = resolveComponent("vueper-slide");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["vueperslides", $options.vueperslidesClasses]),
    ref: "vueperslides",
    "aria-label": "Slideshow",
    style: normalizeStyle($options.vueperslidesStyles)
  }, [
    $options.slidesCount && $options.conf.slideContentOutside === "top" ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(["vueperslide__content-wrapper vueperslide__content-wrapper--outside-top", $options.conf.slideContentOutsideClass])
    }, [
      $options.currentSlide.contentSlot ? (openBlock(), createBlock(_component_vnodes, {
        key: 0,
        vnodes: $options.currentSlide.contentSlot()
      }, null, 8, ["vnodes"])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
        $options.currentSlide.title ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "vueperslide__title",
          innerHTML: $options.currentSlide.title
        }, null, 8, _hoisted_1)) : createCommentVNode("", true),
        $options.currentSlide.content ? (openBlock(), createElementBlock("div", {
          key: 1,
          class: "vueperslide__content",
          innerHTML: $options.currentSlide.content
        }, null, 8, _hoisted_2)) : createCommentVNode("", true)
      ], 64))
    ], 2)) : createCommentVNode("", true),
    createElementVNode("div", _hoisted_3, [
      createElementVNode("div", {
        class: "vueperslides__parallax-wrapper",
        style: normalizeStyle(`padding-bottom: ${$options.conf.slideRatio * 100}%`),
        "aria-live": "polite"
      }, [
        createElementVNode("div", {
          class: normalizeClass(["vueperslides__track", { "vueperslides__track--dragging": _ctx.touch.dragging, "vueperslides__track--mousedown": _ctx.mouseDown }]),
          ref: "track",
          style: normalizeStyle($options.trackStyles)
        }, [
          createElementVNode("div", {
            class: "vueperslides__track-inner",
            style: normalizeStyle($options.trackInnerStyles)
          }, [
            renderSlot(_ctx.$slots, "default"),
            _ctx.isReady && $options.conf.infinite && $options.canSlide && $options.lastSlide ? (openBlock(), createBlock(_component_vueper_slide, {
              key: 0,
              class: "vueperslide--clone vueperslide--clone-1",
              clone: "",
              title: $options.lastSlide.title,
              content: $options.lastSlide.content,
              image: $options.lastSlide.image,
              link: $options.lastSlide.link,
              style: normalizeStyle($options.lastSlide.style),
              lazyloaded: $options.lastSlide.loaded,
              "aria-hidden": "true"
            }, createSlots({ _: 2 }, [
              $options.lastSlide.contentSlot ? {
                name: "content",
                fn: withCtx(() => [
                  createVNode(_component_vnodes, {
                    vnodes: $options.lastSlide.contentSlot()
                  }, null, 8, ["vnodes"])
                ])
              } : void 0,
              $options.conf.lazy && !$options.lastSlide.loaded && $options.lastSlide.loaderSlot ? {
                name: "loader",
                fn: withCtx(() => [
                  createVNode(_component_vnodes, {
                    vnodes: $options.lastSlide.loaderSlot()
                  }, null, 8, ["vnodes"])
                ])
              } : void 0
            ]), 1032, ["title", "content", "image", "link", "style", "lazyloaded"])) : createCommentVNode("", true),
            _ctx.isReady && $options.conf.infinite && $options.canSlide && $options.firstSlide ? (openBlock(), createBlock(_component_vueper_slide, {
              key: 1,
              class: "vueperslide--clone vueperslide--clone-2",
              clone: "",
              title: $options.firstSlide.title,
              content: $options.firstSlide.content,
              image: $options.firstSlide.image,
              link: $options.firstSlide.link,
              style: normalizeStyle($options.firstSlide.style),
              lazyloaded: $options.firstSlide.loaded,
              "aria-hidden": "true"
            }, createSlots({ _: 2 }, [
              $options.firstSlide.contentSlot ? {
                name: "content",
                fn: withCtx(() => [
                  createVNode(_component_vnodes, {
                    vnodes: $options.firstSlide.contentSlot()
                  }, null, 8, ["vnodes"])
                ])
              } : void 0,
              $options.conf.lazy && !$options.firstSlide.loaded && $options.firstSlide.loaderSlot ? {
                name: "loader",
                fn: withCtx(() => [
                  createVNode(_component_vnodes, {
                    vnodes: $options.firstSlide.loaderSlot()
                  }, null, 8, ["vnodes"])
                ])
              } : void 0
            ]), 1032, ["title", "content", "image", "link", "style", "lazyloaded"])) : createCommentVNode("", true)
          ], 4)
        ], 6)
      ], 4),
      ($options.conf.pauseOnHover || $options.conf.pauseOnTouch) && _ctx.$slots.pause ? (openBlock(), createElementBlock("div", _hoisted_4, [
        renderSlot(_ctx.$slots, "pause")
      ])) : createCommentVNode("", true),
      $options.conf.progress ? (openBlock(), createElementBlock("div", _hoisted_5, [
        renderSlot(_ctx.$slots, "progress", {
          current: _ctx.slides.current + 1,
          total: $options.slidesCount
        }, () => [
          createElementVNode("div", {
            style: normalizeStyle(`width: ${(_ctx.slides.current + 1) * 100 / $options.slidesCount}%`)
          }, null, 4)
        ])
      ])) : createCommentVNode("", true),
      $options.conf.fractions ? (openBlock(), createElementBlock("div", _hoisted_6, [
        renderSlot(_ctx.$slots, "fraction", {
          current: _ctx.slides.current + 1,
          total: $options.slidesCount
        }, () => [
          createTextVNode(toDisplayString(`${_ctx.slides.current + 1} / ${$options.slidesCount}`), 1)
        ])
      ])) : createCommentVNode("", true),
      $options.conf.arrows && $options.canSlide && !$props.disable ? (openBlock(), createElementBlock("div", {
        key: 3,
        class: normalizeClass(["vueperslides__arrows", { "vueperslides__arrows--outside": $options.conf.arrowsOutside }])
      }, [
        withDirectives(createElementVNode("button", {
          class: "vueperslides__arrow vueperslides__arrow--prev",
          type: "button",
          onClick: _cache[0] || (_cache[0] = ($event) => $options.previous()),
          "aria-label": "Previous",
          onKeyup: [
            _cache[1] || (_cache[1] = withKeys(($event) => $options.conf.rtl ? $options.next() : $options.previous(), ["left"])),
            _cache[2] || (_cache[2] = withKeys(($event) => $options.conf.rtl ? $options.previous() : $options.next(), ["right"]))
          ]
        }, [
          renderSlot(_ctx.$slots, `arrow-${$options.conf.rtl ? "right" : "left"}`, {}, () => [
            (openBlock(), createElementBlock("svg", _hoisted_7, [
              createElementVNode("path", {
                "stroke-linecap": "round",
                d: $options.conf.rtl ? "m1 1 l7 8 -7 8" : "m8 1 l-7 8 7 8"
              }, null, 8, _hoisted_8)
            ]))
          ])
        ], 544), [
          [vShow, !$options.arrowPrevDisabled]
        ]),
        withDirectives(createElementVNode("button", {
          class: "vueperslides__arrow vueperslides__arrow--next",
          type: "button",
          onClick: _cache[3] || (_cache[3] = ($event) => $options.next()),
          "aria-label": "Next",
          onKeyup: [
            _cache[4] || (_cache[4] = withKeys(($event) => $options.conf.rtl ? $options.next() : $options.previous(), ["left"])),
            _cache[5] || (_cache[5] = withKeys(($event) => $options.conf.rtl ? $options.previous() : $options.next(), ["right"]))
          ]
        }, [
          renderSlot(_ctx.$slots, `arrow-${$options.conf.rtl ? "left" : "right"}`, {}, () => [
            (openBlock(), createElementBlock("svg", _hoisted_9, [
              createElementVNode("path", {
                "stroke-linecap": "round",
                d: $options.conf.rtl ? "m8 1 l-7 8 7 8" : "m1 1 l7 8 -7 8"
              }, null, 8, _hoisted_10)
            ]))
          ])
        ], 544), [
          [vShow, !$options.arrowNextDisabled]
        ])
      ], 2)) : createCommentVNode("", true),
      $options.conf.bullets && $options.canSlide && !$props.disable && !$options.conf.bulletsOutside ? (openBlock(), createElementBlock("div", _hoisted_11, [
        renderSlot(_ctx.$slots, "bullets", {
          currentSlide: _ctx.slides.current,
          bulletIndexes: $options.bulletIndexes,
          goToSlide: $options.goToSlide,
          previous: $options.previous,
          next: $options.next
        }, () => [
          (openBlock(true), createElementBlock(Fragment, null, renderList($options.bulletIndexes, (slideIndex, i) => {
            return openBlock(), createElementBlock("button", {
              class: normalizeClass(["vueperslides__bullet", { "vueperslides__bullet--active": _ctx.slides.current === slideIndex }]),
              type: "button",
              key: i,
              role: "tab",
              "aria-label": `Slide ${i + 1}`,
              onClick: ($event) => $options.goToSlide(slideIndex),
              onKeyup: [
                _cache[6] || (_cache[6] = withKeys(($event) => $options.conf.rtl ? $options.next() : $options.previous(), ["left"])),
                _cache[7] || (_cache[7] = withKeys(($event) => $options.conf.rtl ? $options.previous() : $options.next(), ["right"]))
              ]
            }, [
              renderSlot(_ctx.$slots, "bullet", {
                active: _ctx.slides.current === slideIndex,
                slideIndex,
                index: i + 1
              }, () => [
                createElementVNode("div", _hoisted_13, [
                  createElementVNode("span", null, toDisplayString(i + 1), 1)
                ])
              ])
            ], 42, _hoisted_12);
          }), 128))
        ])
      ], 512)) : createCommentVNode("", true)
    ]),
    $options.conf.bullets && $options.canSlide && !$props.disable && $options.conf.bulletsOutside ? (openBlock(), createElementBlock("div", _hoisted_14, [
      renderSlot(_ctx.$slots, "bullets", {
        currentSlide: _ctx.slides.current,
        bulletIndexes: $options.bulletIndexes,
        goToSlide: $options.goToSlide,
        previous: $options.previous,
        next: $options.next
      }, () => [
        (openBlock(true), createElementBlock(Fragment, null, renderList($options.bulletIndexes, (slideIndex, i) => {
          return openBlock(), createElementBlock("button", {
            class: normalizeClass(["vueperslides__bullet", { "vueperslides__bullet--active": _ctx.slides.current === slideIndex }]),
            type: "button",
            key: i,
            role: "tab",
            "aria-label": `Slide ${i + 1}`,
            onClick: ($event) => $options.goToSlide(slideIndex),
            onKeyup: [
              _cache[8] || (_cache[8] = withKeys(($event) => $options.conf.rtl ? $options.next() : $options.previous(), ["left"])),
              _cache[9] || (_cache[9] = withKeys(($event) => $options.conf.rtl ? $options.previous() : $options.next(), ["right"]))
            ]
          }, [
            renderSlot(_ctx.$slots, "bullet", {
              active: _ctx.slides.current === slideIndex,
              slideIndex,
              index: i + 1
            }, () => [
              createElementVNode("div", _hoisted_16, [
                createElementVNode("span", null, toDisplayString(i + 1), 1)
              ])
            ])
          ], 42, _hoisted_15);
        }), 128))
      ])
    ], 512)) : createCommentVNode("", true),
    $options.slidesCount && $options.conf.slideContentOutside === "bottom" ? (openBlock(), createElementBlock("div", {
      key: 2,
      class: normalizeClass(["vueperslide__content-wrapper vueperslide__content-wrapper--outside-bottom", $options.conf.slideContentOutsideClass])
    }, [
      $options.currentSlide.contentSlot ? (openBlock(), createBlock(_component_vnodes, {
        key: 0,
        vnodes: $options.currentSlide.contentSlot()
      }, null, 8, ["vnodes"])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
        $options.currentSlide.title ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "vueperslide__title",
          innerHTML: $options.currentSlide.title
        }, null, 8, _hoisted_17)) : createCommentVNode("", true),
        $options.currentSlide.content ? (openBlock(), createElementBlock("div", {
          key: 1,
          class: "vueperslide__content",
          innerHTML: $options.currentSlide.content
        }, null, 8, _hoisted_18)) : createCommentVNode("", true)
      ], 64))
    ], 2)) : createCommentVNode("", true)
  ], 6);
}
var vueperslides_vue_vue_type_style_index_0_lang = "";
const _sfc_main = {
  name: "vueper-slides",
  components: {
    VueperSlide,
    vnodes: {
      render() {
        return this.$attrs.vnodes;
      }
    }
  },
  provide() {
    return {
      conf: this.conf,
      slides: this.slides,
      touch: this.touch,
      updateSlide: this.updateSlide,
      addClone: this.addClone,
      addSlide: this.addSlide,
      removeSlide: this.removeSlide
    };
  },
  props: {
    alwaysRefreshClones: { type: Boolean, default: false },
    arrows: { type: Boolean, default: true },
    arrowsOutside: { type: Boolean, default: null },
    autoplay: { type: Boolean, default: false },
    breakpoints: { type: Object, default: () => ({}) },
    bullets: { type: Boolean, default: true },
    bulletsOutside: { type: Boolean, default: null },
    disable: { type: Boolean, default: false },
    disableArrowsOnEdges: { type: [Boolean, String], default: false },
    draggingDistance: { type: Number, default: null },
    duration: { type: [Number, String], default: 4e3 },
    infinite: { type: Boolean, default: true },
    fade: { type: Boolean, default: false },
    fixedHeight: { type: [Boolean, String], default: false },
    fractions: { type: Boolean, default: false },
    gap: { type: Number, default: 0 },
    initSlide: { type: Number, default: 1 },
    lazy: { type: Boolean, default: false },
    lazyLoadOnDrag: { type: Boolean, default: false },
    pauseOnHover: { type: Boolean, default: true },
    pauseOnTouch: { type: Boolean, default: true },
    parallax: { type: [Boolean, Number], default: false },
    pageScrollingElement: { type: String, default: "" },
    parallaxFixedContent: { type: Boolean, default: false },
    preventYScroll: { type: Boolean, default: false },
    progress: { type: Boolean, default: false },
    rtl: { type: Boolean, default: false },
    slideContentOutside: { type: [Boolean, String], default: false },
    slideContentOutsideClass: { type: String, default: "" },
    slideImageInside: { type: Boolean, default: false },
    slideMultiple: { type: [Boolean, Number], default: false },
    slideRatio: { type: Number, default: 1 / 3 },
    touchable: { type: Boolean, default: true },
    transitionSpeed: { type: [Number, String], default: 600 },
    visibleSlides: { type: Number, default: 1 },
    "3d": { type: Boolean, default: false }
  },
  emits: [
    "ready",
    "next",
    "previous",
    "autoplay-pause",
    "autoplay-resume",
    "before-slide",
    "slide",
    "image-loaded",
    "image-failed"
  ],
  data: () => ({
    isReady: false,
    isPaused: false,
    container: null,
    slides: {
      list: [],
      activeId: null,
      current: 0,
      focus: 0,
      firstVisible: 0
    },
    mouseDown: false,
    mouseOver: false,
    touch: {
      enabled: true,
      dragging: false,
      lazyloadTriggered: false,
      justDragged: false,
      dragStartX: 0,
      dragNowX: 0,
      dragAmount: 0
    },
    transition: { currentTranslation: 0, speed: 0, animated: false },
    autoplayTimer: null,
    nextSlideIsClone: false,
    breakpointsData: { list: [], current: null },
    parallaxData: { translation: 0, slideshowOffsetTop: null, isVisible: false }
  }),
  computed: {
    conf() {
      const conf = __spreadValues(__spreadValues({}, this.$props), this.$props.breakpoints && this.$props.breakpoints[this.breakpointsData.current] || {});
      conf.slideMultiple = conf.slideMultiple ? conf.visibleSlides : 1;
      conf.gap = this.gap && parseInt(this.gap) || 0;
      if (conf.visibleSlides > 1)
        conf["3d"] = false;
      if (conf.fade || conf.disableArrowsOnEdges || conf.visibleSlides > 1 || conf["3d"]) {
        conf.infinite = false;
      }
      if (conf.visibleSlides > 1 && conf.arrowsOutside === null)
        conf.arrowsOutside = true;
      if (conf.visibleSlides > 1 && conf.bulletsOutside === null)
        conf.bulletsOutside = true;
      if (this.touch.enabled !== conf.touchable)
        this.toggleTouchableOption(conf.touchable);
      if (conf.parallax && conf.parallaxFixedContent) {
        conf.slideContentOutside = "top";
        conf.slideContentOutsideClass = "parallax-fixed-content";
      }
      return conf;
    },
    slidesCount() {
      return this.slides.list.length;
    },
    gapsCount() {
      const { fade, "3d": threeD, slideMultiple, gap } = this.conf;
      if (!gap || fade || threeD)
        return 0;
      if (this.multipleSlides1by1 && this.slides.current < this.preferredPosition)
        return 0;
      if (!this.slides.current && this.nextSlideIsClone)
        return this.slidesCount;
      if (this.nextSlideIsClone === 0)
        return -1;
      let gapsCount = this.slides.current / slideMultiple - this.preferredPosition;
      if (this.multipleSlides1by1 && this.slidePosAfterPreferred > 0) {
        gapsCount -= this.slidePosAfterPreferred;
      }
      return gapsCount;
    },
    slidesAfterCurrent() {
      return this.slidesCount - (this.slides.current + 1);
    },
    preferredPosition() {
      return this.multipleSlides1by1 ? Math.ceil(this.conf.visibleSlides / 2) - 1 : 0;
    },
    slidePosAfterPreferred() {
      return this.conf.visibleSlides - this.preferredPosition - this.slidesAfterCurrent - 1;
    },
    multipleSlides1by1() {
      return this.conf.visibleSlides > 1 && this.conf.slideMultiple === 1;
    },
    touchEnabled: {
      get() {
        return this.slidesCount > 1 && this.touch.enabled;
      },
      set(value) {
        this.touch.enabled = value;
      }
    },
    canSlide() {
      return this.slidesCount / this.conf.visibleSlides > 1;
    },
    firstSlide() {
      const slide = this.slidesCount ? this.slides.list[0] : {};
      if (slide.style && typeof slide.style === "string") {
        slide.style = slide.style.replace(/width: ?\d+.*?;?/, "");
      }
      return slide;
    },
    lastSlide() {
      const slide = this.slidesCount ? this.slides.list[this.slidesCount - 1] : {};
      if (slide.style && typeof slide.style === "string") {
        slide.style = slide.style.replace(/width: ?\d+.*?;?/, "");
      }
      return slide;
    },
    currentSlide() {
      const currentSlide = this.slidesCount && this.slides.list[this.slides.current] || {};
      if (this.slides.current < this.slidesCount && currentSlide.id !== this.slides.activeId) {
        this.goToSlide(this.slides.current, { animation: false, autoPlaying: true });
      }
      return currentSlide;
    },
    vueperslidesClasses() {
      return {
        "vueperslides--ready": this.isReady,
        "vueperslides--rtl": this.conf.rtl,
        "vueperslides--fade": this.conf.fade,
        "vueperslides--parallax": this.conf.parallax,
        "vueperslides--slide-image-inside": this.conf.slideImageInside,
        "vueperslides--touchable": this.touchEnabled && !this.disable,
        "vueperslides--fixed-height": this.conf.fixedHeight,
        "vueperslides--3d": this.conf["3d"],
        "vueperslides--slide-multiple": this.conf.slideMultiple > 1,
        "vueperslides--bullets-outside": this.conf.bulletsOutside,
        "vueperslides--animated": this.transition.animated,
        "vueperslides--no-animation": !this.isReady
      };
    },
    vueperslidesStyles() {
      return /^-?\d/.test(this.conf.fixedHeight) ? `height: ${this.conf.fixedHeight}` : null;
    },
    trackStyles() {
      const styles2 = {};
      if (this.conf.parallax) {
        styles2.transform = `translate3d(0, ${this.parallaxData.translation}%, 0)`;
        styles2.willChange = this.parallaxData.isVisible ? "transform" : "auto";
      }
      return styles2;
    },
    trackInnerStyles() {
      const styles2 = {};
      const { fade, "3d": threeD } = this.conf;
      styles2.transitionDuration = `${this.transition.speed}ms`;
      if (threeD) {
        const rotation = this.transition.currentTranslation * 90 / 100;
        styles2.transform = `rotateY(-90deg) translateX(-50%) rotateY(90deg) rotateY(${rotation}deg)`;
      } else if (!fade) {
        styles2.transform = `translate3d(${this.transition.currentTranslation}%, 0, 0)`;
        styles2.willChange = this.touch.dragging || this.transition.animated ? "transform" : "auto";
      }
      return styles2;
    },
    bulletIndexes() {
      return Array(Math.ceil(this.slidesCount / this.conf.slideMultiple)).fill().map((v, i) => i * this.conf.slideMultiple);
    },
    arrowPrevDisabled() {
      return !this.slides.current && this.conf.disableArrowsOnEdges;
    },
    arrowNextDisabled() {
      const { disableArrowsOnEdges, visibleSlides, slideMultiple } = this.conf;
      const lastSlide = this.slides.current + (slideMultiple > 1 && visibleSlides > 1 ? visibleSlides - 1 : 0);
      return lastSlide === this.slidesCount - 1 && disableArrowsOnEdges;
    }
  },
  methods: {
    init() {
      this.container = this.$refs.vueperslides;
      this.touchEnabled = this.conf.touchable;
      this.transition.speed = this.conf.transitionSpeed;
      if (Object.keys(this.breakpoints).length) {
        this.setBreakpointsList();
        this.setBreakpointConfig(this.getCurrentBreakpoint());
      }
      const options = { animation: false, autoPlaying: this.conf.autoplay };
      this.goToSlide(this.conf.initSlide - 1, options);
      this.bindEvents();
      this.$nextTick(() => {
        this.isReady = true;
        this.emit("ready");
      });
    },
    emit(name, includeCurrentSlide = true, includeNextSlide = false) {
      let args = null;
      if (includeCurrentSlide || typeof includeNextSlide === "number") {
        args = {};
        if (includeCurrentSlide && this.slides.activeId && this.slidesCount) {
          args.currentSlide = this.getSlideData(this.slides.current);
        }
        if (typeof includeNextSlide === "number" && this.slidesCount) {
          const { nextSlide: nextSlideIndex } = this.getSlideInRange(includeNextSlide);
          args.nextSlide = this.getSlideData(nextSlideIndex);
        }
      }
      this.$emit(...args ? [name, args] : [name]);
    },
    getSlideData(index) {
      const slide = this.slides.list[index];
      let data = {};
      if (slide) {
        data = {
          index,
          title: slide.title,
          content: slide.content,
          contentSlot: slide.contentSlot,
          image: slide.image,
          link: slide.link
        };
      }
      return data;
    },
    setBreakpointsList() {
      this.breakpointsData.list = [99999, ...Object.keys(this.breakpoints)].map((bp) => parseInt(bp)).sort((a, b) => parseInt(b) - parseInt(a));
    },
    getCurrentBreakpoint() {
      const windowWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
      const breakpoints = [windowWidth, ...this.breakpointsData.list].sort((a, b) => parseInt(b) - parseInt(a));
      return this.breakpointsData.list[breakpoints.indexOf(windowWidth) - 1];
    },
    hasBreakpointChanged(breakpoint) {
      return this.breakpointsData.current !== parseInt(breakpoint);
    },
    setBreakpointConfig(breakpoint) {
      const bp = this.breakpoints && this.breakpoints[breakpoint] || {};
      const slideMultipleChanged = bp.slideMultiple && bp.slideMultiple !== this.conf.slideMultiple;
      const visibleSlidesChanged = bp.visibleSlides && bp.visibleSlides !== this.conf.visibleSlides;
      this.breakpointsData.current = breakpoint;
      this.slides.current = this.getFirstVisibleSlide(this.slides.focus);
      if (slideMultipleChanged || visibleSlidesChanged) {
        this.goToSlide(this.slides.current, { breakpointChange: true });
      } else
        this.updateTrackTranslation();
    },
    bindEvents() {
      const hasTouch = "ontouchstart" in window;
      if (this.touchEnabled)
        this.toggleTouchableOption(true);
      if (this.conf.autoplay) {
        if (this.conf.pauseOnHover && !hasTouch) {
          this.container.addEventListener("mouseenter", this.onMouseEnter);
          this.container.addEventListener("mouseleave", this.onMouseLeave);
        } else if (this.conf.pauseOnTouch && hasTouch) {
          document.addEventListener("touchstart", (e) => {
            this[this.$el.contains(e.target) ? "onSlideshowTouch" : "onOustideTouch"]();
          });
        }
      }
      if (this.breakpointsData.list.length || this.conf.parallax) {
        window.addEventListener("resize", this.onResize);
      }
      if (this.conf.parallax) {
        this.refreshParallax();
        if (this.pageScrollingElement) {
          this.parallaxData.scrollingEl = document.querySelector(this.pageScrollingElement);
          this.parallaxData.scrollingEl.addEventListener("scroll", this.onScroll);
        } else
          document.addEventListener("scroll", this.onScroll);
      }
    },
    getSlideshowOffsetTop(force = false) {
      if (this.parallaxData.slideshowOffsetTop === null || force) {
        let el = this.container;
        let top = el.offsetTop;
        while (el = el.offsetParent)
          top += el.offsetTop;
        this.parallaxData.slideshowOffsetTop = top;
      }
      return this.parallaxData.slideshowOffsetTop;
    },
    onScroll() {
      const { scrollingEl } = this.parallaxData;
      const doc = document.documentElement;
      let scrollTop = 0;
      if (scrollingEl)
        scrollTop = scrollingEl.scrollTop;
      else
        scrollTop = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);
      const windowHeight = window.innerHeight || doc.clientHeight || document.body.clientHeight;
      const slideshowHeight = this.container.clientHeight;
      const slideshowTopOffset = this.getSlideshowOffsetTop();
      const vsBottom2WinTop = slideshowTopOffset + slideshowHeight - scrollTop;
      const vsTop2winBottom = windowHeight + scrollTop - slideshowTopOffset;
      this.parallaxData.isVisible = vsBottom2WinTop > 0 && vsTop2winBottom > 0;
      if (this.parallaxData.isVisible) {
        const heightToCoverWithTranslation = windowHeight + slideshowHeight;
        const percentage = vsBottom2WinTop * 100 / heightToCoverWithTranslation;
        const translatePercentage = this.conf.parallax === -1 ? 100 - percentage : percentage;
        this.parallaxData.translation = -translatePercentage / 2;
      }
    },
    onResize() {
      if (this.breakpointsData.list.length) {
        const breakpoint = this.getCurrentBreakpoint();
        if (this.hasBreakpointChanged(breakpoint))
          this.setBreakpointConfig(breakpoint);
      }
      if (this.conf.parallax)
        this.getSlideshowOffsetTop(true);
    },
    onMouseEnter() {
      this.mouseOver = true;
      if (this.conf.pauseOnHover && this.conf.autoplay)
        this.isPaused = true;
    },
    onMouseLeave() {
      this.mouseOver = false;
      if (this.conf.pauseOnHover && this.conf.autoplay)
        this.isPaused = false;
    },
    onMouseDown(e) {
      if (!this.touchEnabled || this.disable)
        return;
      if (!e.touches && this.preventYScroll)
        e.preventDefault();
      this.mouseDown = true;
      this.touch.dragStartX = this.getCurrentMouseX(e);
      if (!this.conf.draggingDistance)
        this.updateTrackTranslation(this.touch.dragStartX);
    },
    onMouseMove(e) {
      if (this.mouseDown || this.touch.dragging) {
        if (this.conf.autoplay)
          this.isPaused = true;
        if (this.preventYScroll)
          e.preventDefault();
        this.mouseDown = false;
        this.touch.dragging = true;
        this.touch.dragNowX = this.getCurrentMouseX(e);
        if (this.conf.draggingDistance) {
          this.touch.dragAmount = this.touch.dragNowX - this.touch.dragStartX;
          const dragAmountPercentage = this.touch.dragAmount / this.container.clientWidth;
          this.updateTrackTranslation();
          this.transition.currentTranslation += 100 * dragAmountPercentage;
        } else
          this.updateTrackTranslation(this.touch.dragNowX);
      }
    },
    onMouseUp(e) {
      this.mouseDown = false;
      if (!this.touch.dragging)
        return this.cancelSlideChange();
      else if (this.conf.autoplay) {
        const hasTouch = "ontouchstart" in window;
        if (!hasTouch && !this.mouseOver)
          this.isPaused = false;
        else if (!this.conf.pauseOnTouch)
          this.isPaused = false;
      }
      this.touch.dragging = false;
      const dragAmount = this.conf.draggingDistance ? -this.touch.dragAmount : 0;
      const dragPercentageStart = (this.touch.dragStartX - this.container.offsetLeft) / this.container.clientWidth;
      const dragPercentageNow = (this.touch.dragNowX - this.container.offsetLeft) / this.container.clientWidth;
      const dragPercentage = ((dragPercentageStart < 0.5 ? 0 : 1) - dragPercentageNow) * 100;
      let forwards = (dragAmount || dragPercentage) > 0;
      if (this.conf.rtl)
        forwards = !forwards;
      const reasonsToCancelSliding = [
        Math.abs(dragAmount) < this.conf.draggingDistance,
        !this.conf.draggingDistance && Math.abs(dragPercentage) < 50,
        this.arrowPrevDisabled && !this.slides.current && !forwards,
        this.arrowNextDisabled && this.slides.current === this.slidesCount - 1 && forwards
      ];
      if (reasonsToCancelSliding.includes(true))
        this.cancelSlideChange();
      else {
        const targetSlide = this.slides.current + this.conf.slideMultiple * (forwards ? 1 : -1);
        this.emit(forwards ? "next" : "previous");
        this.goToSlide(targetSlide);
      }
      this.touch.dragStartX = null;
      this.touch.dragNowX = null;
      this.touch.dragAmount = null;
      this.touch.justDragged = true;
      setTimeout(() => this.touch.justDragged = false, 50);
      this.touch.lazyloadTriggered = false;
    },
    onSlideshowTouch() {
      this.isPaused = true;
    },
    onOustideTouch() {
      this.isPaused = false;
    },
    justDragged() {
      return this.touch.justDragged;
    },
    cancelSlideChange() {
      if (!this.conf.fade)
        this.updateTrackTranslation();
    },
    getCurrentMouseX(e) {
      return "ontouchstart" in window ? e.touches[0].clientX : e.clientX;
    },
    getBasicTranslation() {
      return this.slides.current / this.conf.visibleSlides;
    },
    updateTrackTranslation(currentMouseX = null) {
      let translation = this.getBasicTranslation();
      const { infinite, visibleSlides, slideMultiple, gap, "3d": threeD, lazy, lazyLoadOnDrag } = this.conf;
      if (infinite && this.nextSlideIsClone !== false) {
        translation = (this.nextSlideIsClone ? this.slidesCount : -1) / visibleSlides;
      }
      if (gap) {
        translation += this.gapsCount / (visibleSlides / slideMultiple) * gap / 100;
      }
      if (this.touch.dragStartX && currentMouseX && !(infinite && this.nextSlideIsClone !== false)) {
        let dragPercentage = 0;
        const dragPercentageStart = (this.touch.dragStartX - this.container.offsetLeft) / this.container.clientWidth;
        let dragPercentageNow = (currentMouseX - this.container.offsetLeft) / this.container.clientWidth;
        if (threeD) {
          const range = Math.round(dragPercentageStart) ? [0, 2] : [-1, 1];
          dragPercentageNow = Math.min(Math.max(dragPercentageNow, range[0]), range[1]);
        }
        dragPercentage = (dragPercentageStart < 0.5 ? 0 : 1) - dragPercentageNow;
        translation += dragPercentage * (this.conf.rtl ? -1 : 1);
        if (lazy && lazyLoadOnDrag && !this.touch.lazyloadTriggered) {
          this.touch.lazyloadTriggered = true;
          let nextSlideGuess = this.slides.current + (dragPercentage > 0 ? 1 : -1) * visibleSlides;
          if (infinite && nextSlideGuess === -1)
            nextSlideGuess = this.slidesCount - 1;
          else if (infinite && nextSlideGuess === this.slidesCount)
            nextSlideGuess = 0;
          for (let i = 0; i < visibleSlides; i++) {
            const slide = this.slides.list[nextSlideGuess + i];
            if (slide && !slide.loaded)
              this.loadSlide(slide, nextSlideGuess + i);
          }
        }
      }
      if (this.multipleSlides1by1 && !infinite) {
        const preferredPositionIsPassed = this.slidePosAfterPreferred > 0;
        let subtractFromTranslation = Math.min(this.preferredPosition, this.slides.current);
        if (preferredPositionIsPassed)
          subtractFromTranslation += this.slidePosAfterPreferred;
        translation -= subtractFromTranslation / visibleSlides;
      }
      this.transition.currentTranslation = -translation * 100 * (this.conf.rtl ? -1 : 1);
    },
    pauseAutoplay() {
      this.isPaused = true;
      clearTimeout(this.autoplayTimer);
      this.autoplayTimer = 0;
      this.emit("autoplay-pause");
    },
    resumeAutoplay() {
      this.isPaused = false;
      this.doAutoplay();
      this.emit("autoplay-resume");
    },
    doAutoplay() {
      clearTimeout(this.autoplayTimer);
      this.autoplayTimer = setTimeout(() => {
        this.goToSlide(this.slides.current + this.conf.slideMultiple, { autoPlaying: true });
      }, this.currentSlide.duration || this.conf.duration);
    },
    previous(emit = true) {
      if (emit)
        this.emit("previous");
      this.goToSlide(this.slides.current - this.conf.slideMultiple);
    },
    next(emit = true) {
      if (emit)
        this.emit("next");
      this.goToSlide(this.slides.current + this.conf.slideMultiple);
    },
    refreshParallax() {
      setTimeout(() => {
        this.onResize();
        this.onScroll();
      }, 100);
    },
    getFirstVisibleSlide(index) {
      const { slideMultiple, visibleSlides } = this.conf;
      let firstVisible = this.slides.current;
      if (visibleSlides > 1 && slideMultiple === visibleSlides) {
        firstVisible = Math.floor(index / visibleSlides) * visibleSlides;
      } else if (this.multipleSlides1by1) {
        firstVisible = index - Math.min(index, this.preferredPosition) - Math.max(this.slidePosAfterPreferred, 0);
      }
      return firstVisible;
    },
    getSlideInRange(index, autoPlaying) {
      let clone = false;
      if (this.conf.infinite && index === -1)
        clone = 0;
      else if (this.conf.infinite && index === this.slidesCount)
        clone = 1;
      let newIndex = (index + this.slidesCount) % this.slidesCount;
      if (this.conf.slideMultiple > 1) {
        const lastSlideItems = this.slidesCount % this.conf.slideMultiple || this.conf.slideMultiple;
        const missingItems = this.conf.slideMultiple - lastSlideItems;
        newIndex += index < 0 ? missingItems : 0;
        newIndex = this.getFirstVisibleSlide(newIndex);
      }
      if (this.conf.disableArrowsOnEdges && (index < 0 || index > this.slidesCount - 1) && !autoPlaying) {
        newIndex = this.slides.current;
      }
      return { nextSlide: newIndex, clone };
    },
    goToSlide(index, { animation = true, autoPlaying = false, jumping = false, breakpointChange = false, emit = true } = {}) {
      if (!this.slidesCount || this.disable)
        return;
      if (this.conf.autoplay && !autoPlaying && !this.isPaused) {
        this.isPaused = true;
        this.$nextTick(() => this.isPaused = false);
      }
      this.transition.animated = animation;
      setTimeout(() => this.transition.animated = false, this.transitionSpeed);
      const { nextSlide, clone: nextSlideIsClone } = this.getSlideInRange(index, autoPlaying);
      this.nextSlideIsClone = nextSlideIsClone;
      if (!this.slides.list[nextSlide])
        return;
      if (this.conf.lazy) {
        for (let i = 0; i < this.conf.visibleSlides; i++) {
          const slide = this.slides.list[nextSlide + i];
          if (slide && !slide.loaded)
            this.loadSlide(slide, nextSlide + i);
        }
      }
      if (this.isReady && !jumping && emit)
        this.emit("before-slide", true, nextSlide);
      const nextSlideObj = this.slides.list[nextSlide];
      if (this.isReady && nextSlideObj.video) {
        const currSlideObj = this.slides.list[this.slides.current];
        if (currSlideObj.video)
          currSlideObj.video.pause();
        nextSlideObj.video.play();
      }
      if (nextSlideIsClone !== false) {
        setTimeout(() => {
          const passedCloneBackward = index === -1 && this.slides.current !== this.slidesCount - 1;
          const passedCloneForward = index === this.slidesCount && this.slides.current !== 0;
          const tooLateToSetTimeout = passedCloneBackward || passedCloneForward;
          if (!tooLateToSetTimeout) {
            this.transition.speed = 0;
            this.goToSlide(nextSlideIsClone ? 0 : this.slidesCount - 1, { animation: false, jumping: true });
            setTimeout(() => this.transition.speed = this.conf.transitionSpeed, 50);
          }
        }, this.transition.speed - 50);
      }
      this.slides.current = nextSlide;
      this.slides.firstVisible = this.getFirstVisibleSlide(nextSlide);
      if (!breakpointChange)
        this.slides.focus = nextSlide;
      if (!this.conf.fade)
        this.updateTrackTranslation();
      this.slides.activeId = this.slides.list[this.slides.current].id;
      if (this.conf.autoplay && autoPlaying && !this.isPaused)
        this.doAutoplay();
      if (this.slidesCount) {
        if (this.isReady && !jumping && emit)
          this.emit("slide");
        if (this.isReady && this.conf.bullets && !autoPlaying && !jumping && this.$refs.bullets) {
          const bulletButtons = this.$refs.bullets.children;
          const activeBulletButton = bulletButtons && bulletButtons[this.slides.current / this.conf.slideMultiple];
          if (activeBulletButton && activeBulletButton.nodeName.toLowerCase() === "button") {
            let scrollingDomEl = document.documentElement;
            if (this.pageScrollingElement)
              scrollingDomEl = document.querySelector(this.pageScrollingElement);
            const scrollTop = scrollingDomEl.scrollTop;
            activeBulletButton.focus({ preventScroll: true });
            scrollingDomEl.scrollTop = scrollTop;
          }
        }
      }
    },
    addSlide(newSlide) {
      this.slides.list.push(newSlide);
      if (this.isReady && this.slidesCount === 1 && this.conf.autoplay && this.isPaused) {
        this.isPaused = false;
      }
      return this.slidesCount;
    },
    addClone() {
      this.updateTrackTranslation();
      return this.slidesCount;
    },
    updateSlide(slideId, newProps) {
      let slide = this.slides.list.find((slide2) => slide2.id === slideId);
      if (slide)
        slide = Object.assign(slide, newProps);
    },
    removeSlide(slideId) {
      const index = this.slides.list.findIndex((slide) => slide.id === slideId);
      if (index > -1) {
        this.slides.list.splice(index, 1);
        if (this.slidesCount && slideId === this.slides.activeId) {
          this.goToSlide(index - 1, { autoPlaying: true });
        }
      }
      if (this.slides.current >= this.slidesCount)
        this.goToSlide(0, { autoPlaying: true });
    },
    loadSlide(slide, index) {
      slide.loadImage().then((response) => {
        const { image, style } = response;
        slide.loaded = true;
        slide.image = image;
        slide.style = style;
        this.$emit("image-loaded", this.getSlideData(index));
      }, () => {
        slide.loaded = false;
        this.$emit("image-failed", this.getSlideData(index));
      });
    },
    toggleTouchableOption(isTouchable) {
      const { track } = this.$refs;
      if (!track)
        return;
      this.touchEnabled = isTouchable;
      const hasTouch = "ontouchstart" in window;
      if (isTouchable) {
        this.$refs.track.addEventListener(hasTouch ? "touchstart" : "mousedown", this.onMouseDown, { passive: !this.preventYScroll });
        document.addEventListener(hasTouch ? "touchmove" : "mousemove", this.onMouseMove, { passive: !this.preventYScroll });
        document.addEventListener(hasTouch ? "touchend" : "mouseup", this.onMouseUp, { passive: true });
      } else
        this.removeEventListeners();
    },
    removeEventListeners() {
      const hasTouch = "ontouchstart" in window;
      this.$refs.track.removeEventListener(hasTouch ? "touchstart" : "mousedown", this.onMouseDown, { passive: !this.preventYScroll });
      document.removeEventListener(hasTouch ? "touchmove" : "mousemove", this.onMouseMove, { passive: !this.preventYScroll });
      document.removeEventListener(hasTouch ? "touchend" : "mouseup", this.onMouseUp, { passive: true });
    }
  },
  watch: {
    isPaused(bool) {
      this[bool ? "pauseAutoplay" : "resumeAutoplay"]();
    }
  },
  mounted() {
    this.init();
  },
  beforeUnmount() {
    this.removeEventListeners();
    if (this.pageScrollingElement) {
      document.querySelector(this.pageScrollingElement).removeEventListener("scroll", this.onScroll);
    } else
      document.removeEventListener("scroll", this.onScroll);
    document.removeEventListener("scroll", this.onScroll);
    window.removeEventListener("resize", this.onResize);
    document.removeEventListener("touchstart", (e) => {
      this[this.$el.contains(e.target) ? "onSlideshowTouch" : "onOustideTouch"]();
    });
    this.container.removeEventListener("mouseenter", this.onMouseEnter);
    this.container.removeEventListener("mouseleave", this.onMouseLeave);
  }
};
var vueperslides = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", render]]);
export { VueperSlide, vueperslides as VueperSlides };
